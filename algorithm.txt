var generation = 0;
species = []; <= ordered by total_fitness

new_generation() :
    generation++;
    for each old_species 
	=> create a new_species with champion genome
 
    for each old_species 
	generate X offsprings (25% no crossover)
	   with X = (population_size * sum_of_adjusted_fitness / total_adj_fitness) - 1

    to add new offspring genome g : 
	- If possible, add to first (best fitness) new_species
	- Else, create a new species with g as representative

create_offsprings(specie) :
	offspring_count = ?
	use champion as offspring
	parents = best 70% of old_species
	25% offspings = only mutation (no crossover)
	75% offsprings = mutation & crossover

mate(genome a, genome b):
    c new genome
    c gets random 'matching genes' from a or b
    c gets 'disjoint' & 'excess genes' from most fit parent

mutate(genome a): 
    80% chance to mutate weights
	=> each connection :
	    10% new random value
            90% uniformally perturbed

    for small species (size < 5):
    3% new node
    5% new link    

    for large species (size > 5):
    18% new node
    30% new link

distance( genome a, genome b):
	delta = c1 * E / N + c2 * D / N + c3 * W

	with E the number of excess genes
    		D the number of disjoint genes
    		W the average weight difference of matching genes
   	 	N the number of genes il the larger genome (for normalization)

delta_limit = 3.0

adjusted_fitness = fitness / size_of_species

///////////////////////////////////

population_size = 9

generation 1 : 
    species 1 : a1 (champ),
		b1, 
		c1, 
		d1, 
		e1 (eliminated),
		f1 (eliminated)
		=> 5 offsprings

    species 2 : g1 (champ), 
		h1, 
		i1 (eliminated) 
		=> 4 offprings

generation 2 : 
    species 1 :
        a2 = a1 (champ)
        b2 = mutate(c1)
        c2 = a1 x d1
        d2 = b1 x c1
   species 2 :
        e2 = c1 x d1
   species 3 :
        f2 = g1 (champ)
        g2 = mutate(h1)
        h2 = g1 x h1
        i2 = g1 x h1




















